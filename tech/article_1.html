<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 6.12.3 (455520)"/><meta name="altitude" content="76.30600738525391"/><meta name="author" content="川島一朔"/><meta name="created" content="2017-11-16 10:00:55 +0000"/><meta name="latitude" content="35.79083295894519"/><meta name="longitude" content="139.4560393607365"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2017-11-22 07:29:12 +0000"/><title>「Python機械学習プログラミング」第9章に挑む</title></head><body><div><span style="font-size: 18px; font-weight: bold;">「Python機械学習プログラミング」第9章に挑む</span></div><div><br/></div><div>環境：Windows10, Python 2.7, Python 3.6</div><div><br/></div><div><span style="font-weight: bold;">9.2 データストレージとしてSQLiteデータベースをセットアップする</span></div><div><br/></div><div>9.1 はさくっと終わらせて、こちらから。</div><div><br/></div><div>そもそもSQLiteってなんなのか。ググってみてもよくわからない。</div><div>下記URLが唯一理解可能だった。</div><div><a href="http://wa3.i-3-i.info/word11778.html">http://wa3.i-3-i.info/word11778.html</a></div><div><br/></div><div><span style="font-size: 9pt;" title="Page 280"><span style="font-size: 9pt; font-family: HiraKakuProN; font-style: italic;">ここでは、Webアプリケーションの予測に対するユーザーからのフィードバックを収集する。そのために、単純なSQLiteデータベースをセットアップする。</span></span></div><div><br/></div><div>つまり、WEBページにコメント送信フォームみたいなのをつけたとき、その送信されたデータをSQLiteっていうデータベースに保存する的な話かな。</div><div><br/></div><div>さっそくひとつめのコードを見てみる。</div><div><br/></div><div>import sqlite3</div><div>import os</div><div>if os.path.exists('reviews.sqlite'):</div><div>    os.remove('reviews.sqlite')</div><div><br/></div><div>↑カレントディレクトリにreviews.sqliteがあったら消しておく</div><div><br/></div><div>conn = sqlite3.connect('reviews.sqlite')</div><div><br/></div><div>↑reviews.sqliteというファイルを開く。</div><div> カレントディレクトリに該当ファイルがない場合、新規作成する。</div><div><br/></div><div>c = conn.cursor()</div><div><br/></div><div>↑reviews.sqliteをもとに、cursorって種類のインスタンスを作る。</div><div><br/></div><div>c.execute('CREATE TABLE review_db (review TEXT, sentiment INTEGER, date TEXT)')</div><div><br/></div><div>↑「インスタンス c の中に、レビューデータベースのテーブルを作れ。</div><div>テーブルの名前は review_db な。</div><div>テーブルの内容は、reviewって名前のテキスト列と、sentiment（感情）って名前の整数列と、dateって名前のテキスト列で。」</div><div><br/></div><div>example1 = 'I love this movie'</div><div><br/></div><div>↑後に、この文章の感情価を推定するのかな。</div><div><br/></div><div>c.execute("INSERT INTO review_db (review, sentiment, date) VALUES (?, ?, DATETIME('now'))", (example1, 1))</div><div><br/></div><div>↑見慣れない形式だ。?て。</div><div>VALUESの中に?を使った場合は、第二引数にタプル形式で?の中身を指定するらしい。</div><div>さっき作ったreview_dbに、情報を加えろ。</div><div>review, sentiment, dateの列に追加するぞ。</div><div>値は順に、?、?、現在日時。</div><div>?にはexample1と1を入れろ。」</div><div><br/></div><div>example2 = 'I disliked this movie'</div><div><br/></div><div>↑この文章も後で推定するのかな。</div><div><br/></div><div>c.execute("INSERT INTO review_db (review, sentiment, date) VALUES (?, ?, DATETIME('now'))", (example2, 0))</div><div><br/></div><div>↑さっきと同じようにexample2をreview_dbに追加。sentimentの値は、0で。</div><div><br/></div><div>conn.commit()</div><div><br/></div><div>↑データベースに追加・削除をした後にはこれをやって変更を保存するらしい。</div><div>これで、reviews.sqliteの中にはexample1とexample2という2つのデータが保存されたわけだ。</div><div><br/></div><div>conn.close()</div><div><br/></div><div>↑ファイルを閉じる。</div><div><br/></div><div>次のコードは、revies.sqliteの中身を覗いてみるためのもの。</div><div><br/></div><div>conn = sqlite3.connect('reviews.sqlite')</div><div>c = conn.cursor()</div><div>c.execute("SELECT * FROM review_db WHERE date BETWEEN '2015-01-01 10:10:10' AND DATETIME('now')")</div><div><br/></div><div>↑「c の中の review_db から選択しろ。</div><div>ただし、date列が2015年元旦から現在までのやつな。」</div><div>選択て。独特だ。</div><div>イメージとしては、エクセル開いて行を選択してる感じなのかな。</div><div>マクロ書いてるみたい。</div><div><br/></div><div>results = c.fetchall()</div><div><br/></div><div>↑c の中で選択したすべての行を取得する。</div><div><br/></div><div>conn.close()</div><div><br/></div><div><span style="line-height: 1.45;">resultsの中身を見てみる。</span></div><div><br/></div><div>[(u'I love this movie', 1, u'2017-11-19 05:53:00'),</div><div>(u'I disliked this movie', 0, u'2017-11-19 05:53:00')]</div><div><br/></div><div>うまくいってる。</div><div><br/></div><div>SQLite Manager はいつか試しましょう。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.3 Flaskを使ってWebアプリケーションを開発する</span></div><div><br/></div><div><span style="line-height: 1.45;">Flaskとは、Webアプリケーションフレームワークのひとつだという。</span></div><div><span style="line-height: 1.45;">Webアプリを作るための関数集？みたいな？</span></div><div>Wikipediaにはこんなことが書いてあった</div><div><br/></div><div><span style="font-style: italic;">FlaskはArmin Ronacherによって開発された。彼は『エイプリルフールのジョークとして作ったのだけれど、有名になって、いつのまにか本格的なアプリケーションになってしまった』と述べている。</span></div><div><br/></div><div>さっそく flask を pip でインストール。</div><div>一旦 Python を 終了させて、コマンドプロンプト上で pip install flask。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.3.1 はじめての Flask Web アプリケーション</span></div><div>1st_flask_app_1というフォルダを作る。</div><div>その中にapp.pyってファイルとtemplatesってフォルダを作る。</div><div>templatesってフォルダの中に、first_app.htmlってファイルを作る。</div><div><br/></div><div>app.pyの中身は下記</div><div><br/></div><div>from flask import Flask, render_template</div><div><span style="line-height: 1.45;">app = Flask(__name__)</span></div><div><br/></div><div><span style="line-height: 1.45;">↑__name__って引数には、直接 py ファイルが実行されると '__main__' という文字列が代入される。</span></div><div><span style="line-height: 1.45;">モジュールとしてimportされると、__name__ にはそのモジュール名（app.py だったら、'app'）が代入される。</span></div><div><span style="font-style: italic;">__name__という引数で初期化することで、HTMLテンプレートフォルダ（templates）がこのモジュールと同じフォルダで見つかることをFLaskに知らせている。</span></div><div>とあるが、どうしてそんな動きになるんだろう。</div><div><br/></div><div>@app.route('/')</div><div>def index():</div><div>    return render_template('first_app.html')</div><div><br/></div><div>↑特定のディレクトリ（'/'の場合だと、py ファイルと同じ場所）にアクセスがあったら index() を実行するって意味になるらしい。</div><div>@マークを使ったデコレーターってのは関数の内容をちょっと変える時に使うものだとか。</div><div>ルートデコレーターってのはちょっと違うものなのか…？</div><div><br/></div><div>if __name__ == '__main__':</div><div>    app.run(debug=True)</div><div><br/></div><div>↑直接 py ファイルが呼び出されたときには、appインスタンスを run させる。</div><div>run って function は、http://127.0.0.1:5000/ みたいなローカルサーバーアドレスを作成するためのもの？</div><div>実際にWEBアプリケーションとして外部から実行する際はローカルのアドレスを作る必要がなくて、そういうときは __name__ == '__main__' にならない…ってこと？違う気がする。</div><div><br/></div><div>first_app.html には、大したこと書いてないな。</div><div>一文表示するだけ。</div><div><br/></div><div>ターミナル（コマンドプロンプト）画面に python app.py と打つと、教科書通りにローカルアドレスが出てくる。</div><div>WEBブラウザに入力すると Hello World 的な一文を拝める。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.3.2 はじめての Flask Web アプリケーション</span></div><div><br/></div><div>pip install wtforms で問題なくインストール。</div><div>1st_flask_app_2 というフォルダを新規作成。</div><div>その中にさっきの app.py と template フォルダ（中身ごと）をコピー。</div><div>さらに、static フォルダを新規作成。</div><div>templateフォルダ内に _formhelpers.html と hello.html を作成</div><div><br/></div><div>app.py ファイルを下記の通りに書き換える</div><div><br/></div><div>from flask import Flask, render_template, request</div><div>from wtforms import Form, TextAreaField, validators</div><div>app = Flask(__name__)</div><div><br/></div><div>class HelloForm(Form):</div><div>    sayhello = TextAreaField('',[validators.DataRequired()])</div><div><br/></div><div>↑<span style="line-height: 1.45;">Form を引数にしているが、class の中で使ってないのがよくわからん。</span></div><div><span style="line-height: 1.45;">varidators は、wtform からインポートされているモジュールで、その中のDataRequired() って関数（クラスらしい）を呼んでいる。</span></div><div><span style="line-height: 1.45;">たぶん、DataRequired() が Form を参照するのかな。</span></div><div>クラスの名前は大文字にするっていう慣習があるらしいから、<span style="line-height: 1.45;">TextAreaField もクラスなんだろう。</span></div><div>HelloForm で作ったインスタンスの中には sayhello っていうクラス変数ができて、sayhello もインスタンス。</div><div>クラス変数ってのはインスタンス変数と違って、クラスそのものが持つ変数。</div><div>なのでクラス変数を変更すると、次にそのクラスから作ったインスタンスに影響する…って理解でいいのだろうか。</div><div>するとこのクラスで作ったインスタンスは空っぽでは？</div><div><br/></div><div>@app.route('/')</div><div>def index():</div><div>    form = HelloForm(request.form)</div><div>    return render_template('first_app.html', form=form)</div><div><br/></div><div><span style="line-height: 1.45;">↑app.py があるディレクトリにアクセスがあったら、index() を実行。</span></div><div>form ってインスタンスの中身はなんなだろう。</div><div>request.form というのも、何を意味しているのか。</div><div><br/></div><div>@app.route('/hello', methods=['POST'])</div><div><br/></div><div><span style="line-height: 1.45;">↑app.py があるディレクトリの下にある、hello ってディレクトリにアクセスがあったら hello() を実行？</span></div><div>hello なんてフォルダないけど。</div><div>実際になくても、そこにアクセスしようとする動きがあればいいのかな。</div><div>hello.html のことじゃないもんね？</div><div><span style="line-height: 1.45;">二つ目 method=['POST'] てのはなんなんだ。</span></div><div><span style="line-height: 1.45;">後のコードから見て、request.method っていう変数に 'POST' を代入しているのか。</span></div><div><br/></div><div>def hello():</div><div>    form = HelloForm(request.form)</div><div>    if request.method == 'POST' and form.validate():</div><div><br/></div><div>↑上の方で method=['POST'] って書いたのがここで効く？</div><div>.validate() というのは form のインスタンスメソッド？</div><div>フォームにちゃんと入力があれば True を返してくれるんだろうけど。</div><div>どこで form に機能を持たせているのかわからん。</div><div><br/></div><div>        name = request.form['sayhello']</div><div>        return render_template('hello.html', name=name)</div><div><br/></div><div>↑form の中の sayhello っていうクラス変数に大して、request をかけると、フォームの中身が name に格納される？</div><div><span style="line-height: 1.45;">レンダリングってのは、HTMLやCSSスクリプトを読み取って、WEBページを表示すること。</span></div><div>つまり、hello.html を表示するということ。</div><div>ただし、hello.html のうち name って変数に name の中身（フォームの中身）を渡している。</div><div><br/></div><div>    return render_template('first_app.html', form=form)</div><div><br/></div><div>↑form.validate() がFalseだと、first_app.html を表示する。</div><div><br/></div><div>if __name__ == '__main__':</div><div>    app.run(debug=True)</div><div><br/></div><div>この辺、Python の基礎知識が足りてない気がする…</div><div><br/></div><div>次は _formhelpers.html。</div><div>Jinja2 という言語で書かれているとか。</div><div>なにをしてるのか全然わからないので勘弁してください。</div><div><br/></div><div>次いで、style.css。<span style="line-height: 1.45;">これはシンプル。</span></div><div>WEBページの内容を書き込むのがHTMLで、そのHTMLの見た目を修飾するのがCSS。</div><div><br/></div><div>first_app.html のコードを下記のように直す（なぜか ch09.pynb にない？）。</div><div><br/></div><div>&lt;!doctype html&gt;</div><div>&lt;html&gt;</div><div>  &lt;head&gt;</div><div>    &lt;title&gt;First app&lt;/title&gt;</div><div>    &lt;link rel="stylesheet"</div><div>          href="{{ url_for('static', filename='style.css')}}"&gt;</div><div>  &lt;/head&gt;</div><div>  &lt;body&gt;</div><div>  {% from "_formhelpers.html" import render_field %}</div><div><br/></div><div>↑Jinja2で書いたコードのうち、render_field てのを呼び出しているようだ。</div><div><br/></div><div>  &lt;div&gt;</div><div>    なまえを　いれてください</div><div>  &lt;/div&gt;</div><div>  &lt;form method=post action="/hello"&gt;</div><div>    &lt;dl&gt;</div><div>      {{ render_field(form.sayhello) }}</div><div>    &lt;/dl&gt;</div><div>    &lt;input type=submit value='おわり' name='submit_btn'&gt;</div><div>  &lt;/form&gt;</div><div>&lt;/body&gt;</div><div>&lt;/html&gt;</div><div><br/></div><div>↑app.py で出てきた変数名がちらほら。</div><div>このHTMLで定義した変数を、app.py は読み込んでいるのか？</div><div>formタグのうち、action="URI" は、送信先プログラムのURIを指定している、らしい。</div><div>URIてのはURLみたいなもの、正確にはURLもURIの一種、というだけの理解でいいだろうか。</div><div>とにかくこれで、/hello っていう架空のディレクトリ？にアクセスしている。</div><div>method="HTTPメソッド" は、送信の際の転送方法を指定している、らしい。</div><div><br/></div><div>hello.html の中身は下記</div><div><br/></div><div>&lt;!doctype html&gt;</div><div>&lt;html&gt;</div><div>  &lt;head&gt;</div><div>    &lt;title&gt;First app&lt;/title&gt;</div><div>    &lt;link rel="stylesheet"</div><div>          href="{{ url_for('static', filename='style.css')}}"&gt;</div><div>  &lt;/head&gt;</div><div>  &lt;body&gt;</div><div>    &lt;div&gt;</div><div>    おお {{ name }}！&lt;br&gt;</div><div>    ゆうしゃロトの　ちをひくものよ！&lt;br&gt;</div><div>    そなたのくるのをまっておったぞ。</div><div>    &lt;/div&gt;</div><div>  &lt;/body&gt;</div><div>&lt;/html&gt;</div><div><br/></div><div><br/></div><div>↑{{ name }}という書き方で、プレースホルダを作れるようだ。</div><div><br/></div><div>実行。ローカルアドレスを入力すると、下記のエラーメッセージ。</div><div><br/></div><div>jinja2.exceptions.UndefinedError</div><div>UndefinedError: 'form' is undefined</div><div><br/></div><div>単純に app.py が変更されていないだけだった。</div><div>再度変更すると成功。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.4 映画レビュー分類器をWebアプリケーションとして実装する</span></div><div><br/></div><div><span style="line-height: 1.45;">ここからが本番。</span></div><div>しかし新しいことはない様子なので、結果だけ見て省略してしまおう。</div><div>実行してみると、 pickle の load にエラーを起こしている。</div><div>Python 3 で漬け込んだ pickle は Python 2 でロードできないそうだ。</div><div>Python 3 から漬け込むときに、</div><div><br/></div><div>pickle.dump(～, protocol=2)</div><div><br/></div><div>とすればいいらしい。</div><div>今回はPython 3.6をインストールしてやりなおし。</div><div><br/></div><div>WEBアプリの起動と予測自体はうまくいったが、correct を押すとエラーになる。</div><div>Incorrect でも同様。</div><div>SGDClassifier object has no attribute 'max_iter'</div><div><br/></div><div><a href="https://www.pythonanywhere.com/forums/topic/11716/">https://www.pythonanywhere.com/forums/topic/11716/</a></div><div>↑でも同様のエラーが報告されている。</div><div><br/></div><div>pip3.6 install --user --upgrade scikit-learn==0.19.0</div><div>とやれば直るよ！と書いてあるように見えるが、pip3.6なんてものはないと言われる。</div><div>ググってもpip3.6というものの正体がわからない。</div><div><br/></div><div>とにかくscikit-learnのバージョンが悪いのかと考え、古いVerをインストールすることに。</div><div>py -3 -m pip install scikit-learn==0.18.0とうつと、</div><div>Visual C++ 14.0が必要と言われる。</div><div><a style="line-height: 1.45;" href="https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017">https://www.visualstudio.com/downloads/#build-tools-for-visual-studio-2017</a></div><div>↑からBuild Toolsをインストール。</div><div>PCを再起動させ、再度py -3 -m pip install scikit-learn==0.18.0。</div><div>インストールはうまくいく。</div><div><br/></div><div>再度app.py を起動させてcorrectを押すと、問題なく Thank you のページが表示される。</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.5 WebアプリケーションをパブリックWebサーバーにデプロイする</span></div><div><br/></div><div>教科書通り、PythonAnywhereのアカウントを取得する。</div><div>さらに教科書通りにWebアプリケーションの作成を進めていく。</div><div>[Add a new web app] ボタンをクリックすると、Create new web appというダイアログが出る。</div><div>まず、domain nameについて出て来るが、無料だとそのままNextを押す他ないようだ。</div><div>FlaskとPython3.6を選ぶ。</div><div>なにやらPathを指定しろと出てくる。</div><div>mysite/flask_app.pyとなっているのをmovieclassifier/app.pyに変えてNext。</div><div>メニュー左のDirectoriesから、mysite/をクリックし、</div><div>Files タブからUpload a file をクリック。</div><div>ひとつずつしかファイルをアップできないが、ひとつずつやれということだろうか。</div><div>頑張ってひとつずつアップ。</div><div>教科書通りにReloadを行い、<a href="http://issakuss.pythonanywher.com">http://issakuss.pythonanywhere.com</a> にアクセス。</div><div><br/></div><div>うまくいった！</div><div><br/></div><div><br/></div><div><span style="font-weight: bold;">9.5.1 映画レビュー分類器を更新する</span></div><div><span style="font-weight: bold;"><br/></span></div><div>app.py と同じディレクトリに update.py を作成。</div><div>中身はこちら↓</div><div><br/></div><div>import pickle</div><div>import sqlite3</div><div>import numpy as np</div><div>import os</div><div><br/></div><div># import HashingVectorizer from local dir</div><div>from vectorizer import vect</div><div><br/></div><div>def update_model(db_path, model, batch_size=10000):</div><div>    conn = sqlite3.connect(db_path)</div><div>    c = conn.cursor()</div><div>    c.execute('SELECT * from review_db')</div><div>    results = c.fetchmany(batch_size)</div><div><br/></div><div>↑変数 results に、SQLite のデータのうち10000個（行）を代入。</div><div><br/></div><div>    while results:</div><div><br/></div><div>↑resultsの中身が空になるまで実行。</div><div><br/></div><div>        data = np.array(results)</div><div>        X = data[:, 0]</div><div>        y = data[:, 1].astype(int)</div><div><br/></div><div>↑Xに予測子、Yに教師信号を代入</div><div><br/></div><div>        classes = np.array([0, 1])</div><div>        X_train = vect.transform(X)</div><div>        model.partial_fit(X_train, y, classes=classes)</div><div><br/></div><div>↑学習実行。partial_fitという関数で、データの一部だけでとりあえず学習ということができるようだ。</div><div><br/></div><div>        results = c.fetchmany(batch_size)</div><div><br/></div><div>↑次の1万個を results に入れて、while 構文内をもう一周。</div><div><br/></div><div>    conn.close()</div><div>    return model</div><div><br/></div><div>cur_dir = os.path.dirname(__file__)</div><div><br/></div><div>clf = pickle.load(open(os.path.join(cur_dir,</div><div>                  'pkl_objects',</div><div>                  'classifier.pkl'), 'rb'))</div><div>db = os.path.join(cur_dir, 'reviews.sqlite')</div><div><br/></div><div>clf = update_model(db_path=db, model=clf, batch_size=10000)</div><div><br/></div><div>pickle.dump(clf, open(os.path.join(cur_dir,<br/></div><div>       <span>    </span> 　     'pkl_objects', 'classifier.pkl'), 'wb')</div><div><span>    <span>    </span></span>            , protocol=4)</div><div><br/></div><div>app.py の冒頭に、インポートのための一文を入れる↓</div><div>from update import update_model</div><div><br/></div><div>さらにapp.pyの最後に、下記のコードを入れる。</div><div>if __name__ == '__main__':</div><div><span>    clf = update_model(dp_path=db, model=clf, batch_size=10000)</span><br/></div><div><span><br/></span></div><div>お手本コードだとapp.pyが編集されていないようにみえる。</div><div>これであってるのだろうか。</div><div>教科書には三点ドットが書いてあるけれど、これは必要ないよな…？</div><div><br/></div><div>Pythonanywhere に update.py をアップロード。</div><div><br/></div><div>うまくいったか試してみよう。</div><div>試しに、データベースにないであろう語を使った文章を入れてみる。</div><div>ということで、Om Mani Padme Hum と書いてsubmit。</div><div>判定結果はPositiveで、自信は51.63%だという。</div><div>「一応 Positive にしたけど訳分からん」といった様子だ（全くもって正しい）。</div><div>これに対して、Correct を押してやる。</div><div>もう一度 Om Mani Padme Hum と書いてsubmitすると、今度は54.01%の自信をもって返ってきた。</div><div>何度か繰り返すと、72.27%の自信でCorrectと返すようにまでなった。</div><div>チベット仏教のマントラは、映画を褒める言葉として機械に認識されたようだ。</div><div><br/></div></body></html>